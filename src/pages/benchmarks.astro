---
import SiteLayout from '../layouts/SiteLayout.astro';
import {
  benchmarkSources,
  connectorRows,
  splitterRows,
  typicalPythonSplitterRangeMibPerSec,
} from '../data/benchmarks';

const splitterPeak = Math.max(...splitterRows.map((row) => row.throughputMibPerSec));
const lowerMultiplier = Math.round(splitterPeak / typicalPythonSplitterRangeMibPerSec.high);
const upperMultiplier = Math.round(splitterPeak / typicalPythonSplitterRangeMibPerSec.low);
---

<SiteLayout title="Benchmarks" description="Performance comparison of Wesichain vs Python alternatives">
  <div class="mx-auto max-w-4xl px-4 py-16 sm:px-6 lg:px-8">
    <div class="text-center">
      <h1 class="text-4xl font-bold tracking-tight text-white">Benchmarks</h1>
      <p class="mt-4 text-lg text-neutral-400">
        Transparent, reproducible performance comparisons
      </p>
    </div>

    <div class="mt-16 space-y-12">
      <!-- Text Splitting Benchmark -->
      <section class="rounded-2xl border border-neutral-800 bg-neutral-900 p-8">
        <h2 class="text-2xl font-bold text-white">Recursive Text Splitting</h2>
        <p class="mt-2 text-neutral-400">
          Document chunking throughput with UTF-8 safe separators
        </p>

        <div class="mt-6 overflow-hidden rounded-lg border border-neutral-800">
          <table class="w-full text-left">
            <thead class="bg-neutral-950">
              <tr>
                <th class="px-6 py-4 text-sm font-semibold text-white">Input Size</th>
                <th class="px-6 py-4 text-sm font-semibold text-white">Time (avg)</th>
                <th class="px-6 py-4 text-sm font-semibold text-rust-500">Throughput</th>
                <th class="px-6 py-4 text-sm font-semibold text-white">Notes</th>
              </tr>
            </thead>
            <tbody class="divide-y divide-neutral-800">
              {splitterRows.map((row, index) => (
                <tr class={index === 0 ? 'bg-rust-600/5' : ''}>
                  <td class={index === 0 ? 'px-6 py-4 font-medium text-white' : 'px-6 py-4 text-neutral-300'}>{row.size}</td>
                  <td class={index === 0 ? 'px-6 py-4 text-white' : 'px-6 py-4 text-neutral-400'}>{row.avgTime}</td>
                  <td class={index === 0 ? 'px-6 py-4 font-semibold text-rust-500' : 'px-6 py-4 font-semibold text-neutral-300'}>{row.throughputMibPerSec} MiB/s</td>
                  <td class="px-6 py-4 text-neutral-400">{index === 0 ? 'Baseline' : index === 1 ? 'Consistent scaling' : 'Large input overhead'}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <div class="mt-6 rounded-xl border border-rust-600/20 bg-rust-600/5 p-4">
          <h3 class="font-semibold text-rust-500">vs Python: ~{lowerMultiplier}-{upperMultiplier}x faster</h3>
          <p class="mt-1 text-sm text-neutral-400">
            Typical Python recursive text splitters achieve ~{typicalPythonSplitterRangeMibPerSec.low}-{typicalPythonSplitterRangeMibPerSec.high} MiB/s.
            Wesichain's Rust implementation peaks at {splitterPeak} MiB/s in the current artifact snapshot.
          </p>
        </div>

        <p class="mt-4 text-sm text-neutral-500">
          Methodology: Measured with Criterion on macOS. Chunk size: 1000 chars, overlap: 200 chars.
          Run: <code class="rounded bg-neutral-950 px-1 py-0.5">cargo bench -p wesichain-retrieval --bench recursive_splitter</code>
        </p>
      </section>

      <!-- Connector Payload Benchmarks -->
      <section class="rounded-2xl border border-neutral-800 bg-neutral-900 p-8">
        <h2 class="text-2xl font-bold text-white">Connector Payload Microbenchmarks</h2>
        <p class="mt-2 text-neutral-400">
          Local payload construction snapshots for Qdrant and Weaviate connectors
        </p>

        <div class="mt-6 overflow-hidden rounded-lg border border-neutral-800">
          <table class="w-full text-left">
            <thead class="bg-neutral-950">
              <tr>
                <th class="px-6 py-4 text-sm font-semibold text-white">Benchmark</th>
                <th class="px-6 py-4 text-sm font-semibold text-white">Wesichain mean</th>
                <th class="px-6 py-4 text-sm font-semibold text-white">Baseline mean</th>
                <th class="px-6 py-4 text-sm font-semibold text-rust-500">Delta</th>
              </tr>
            </thead>
            <tbody class="divide-y divide-neutral-800">
              {connectorRows.map((row, index) => (
                <tr class={index === 0 ? 'bg-rust-600/5' : ''}>
                  <td class={index === 0 ? 'px-6 py-4 text-white' : 'px-6 py-4 text-neutral-300'}>{row.name}</td>
                  <td class="px-6 py-4 text-white font-mono">{row.wesichainMs.toFixed(3)} ms</td>
                  <td class="px-6 py-4 text-neutral-300 font-mono">{row.baselineMs.toFixed(3)} ms</td>
                  <td class="px-6 py-4 text-rust-500 font-medium">{(row.baselineMs / row.wesichainMs).toFixed(2)}x faster</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <p class="mt-4 text-sm text-neutral-500">
          Caveat: these snapshots are single local runs on synthetic datasets and benchmark local payload
          construction only (no live network call timing). Source files: <code>{benchmarkSources.qdrantJson}</code>, <code>{benchmarkSources.weaviateJson}</code>.
        </p>
      </section>

      <!-- Test Parameters -->
      <section class="rounded-xl border border-neutral-800 bg-neutral-950 p-6">
        <h3 class="font-semibold text-white">Test Parameters</h3>
        <div class="mt-4 grid gap-4 sm:grid-cols-2">
          <div>
            <h4 class="text-sm font-medium text-neutral-300">Text Splitter</h4>
            <ul class="mt-2 space-y-1 text-sm text-neutral-400">
              <li>• Default separators: <code>["\n\n", "\n", " ", ""]</code></li>
              <li>• Chunk size: 1000 characters</li>
              <li>• Overlap: 200 characters</li>
              <li>• Character-based: UTF-8 safe</li>
            </ul>
          </div>
          <div>
            <h4 class="text-sm font-medium text-neutral-300">Environment</h4>
            <ul class="mt-2 space-y-1 text-sm text-neutral-400">
              <li>• Platform: macOS (Darwin)</li>
               <li>• Rust version: 1.92.0 in latest connector snapshots</li>
               <li>• Optimization: --release</li>
               <li>• CPU: Apple Silicon M-series</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- Reproducibility -->
      <section class="rounded-xl border border-neutral-800 bg-neutral-950 p-6">
        <h3 class="font-semibold text-white">Reproducing These Results</h3>
        <p class="mt-2 text-sm text-neutral-400">
          All benchmarks are open source and reproducible. Run them yourself:
        </p>
        <pre class="mt-4 overflow-x-auto rounded-lg bg-neutral-900 p-4 text-sm"><code>git clone https://github.com/wesichain/wesichain.git
cd wesichain
cargo bench -p wesichain-retrieval --bench recursive_splitter
cargo bench -p wesichain-qdrant --bench vs_langchain -- --sample-size 10
cargo bench -p wesichain-weaviate --bench vs_langchain -- --sample-size 10</code></pre>
        <p class="mt-4 text-sm text-neutral-500">
          Results saved to <code>target/criterion/</code> for detailed analysis with confidence intervals.
        </p>
      </section>
    </div>
  </div>
</SiteLayout>
