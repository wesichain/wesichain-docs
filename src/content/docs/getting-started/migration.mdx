---
title: Migration Guide
description: Move from LangChain/LangGraph concepts to Wesichain crates
group: Getting Started
order: 4
---

# Migration Guide

This guide maps common Python LangChain/LangGraph concepts to Wesichain's modular Rust crates.

## Concept Mapping

| Python ecosystem | Wesichain equivalent |
|---|---|
| `Runnable` composition | `Runnable<I, O>` + `.then()` |
| `@tool` | `impl Tool for MyTool` |
| `StateGraph` | `GraphBuilder` / `ReActGraphBuilder` |
| Checkpointer plugins | `wesichain-checkpoint-*` crates |
| LangSmith tracing | `wesichain-langsmith` |

## Recommended Crate Set

```toml
[dependencies]
tokio = { version = "1", features = ["macros", "rt-multi-thread"] }
wesichain-core = "0.2.1"
wesichain-llm = "0.2.1"
wesichain-graph = "0.2.1"

# Optional, based on use case:
# wesichain-rag = "0.2.1"
# wesichain-checkpoint-sqlite = "0.2.1"
# wesichain-checkpoint-postgres = "0.2.1"
# wesichain-compat = "0.2.1"
```

## ReAct Migration Pattern

- **Legacy style:** monolithic agent executors.
- **Current Wesichain recommendation:** build a graph with `ReActGraphBuilder` and explicit state traits (`StateSchema`, `ScratchpadState`, `HasUserInput`, `HasFinalOutput`).

```rust
use std::sync::Arc;

use wesichain_core::{Tool, ToolCallingLlm};
use wesichain_graph::ReActGraphBuilder;

let llm: Arc<dyn ToolCallingLlm> = Arc::new(my_llm);
let tools: Vec<Arc<dyn Tool>> = vec![Arc::new(SearchTool), Arc::new(CalculatorTool)];

let graph = ReActGraphBuilder::new()
    .llm(llm)
    .tools(tools)
    .build::<AppState>()?;
```

## Graph State Migration Pattern

Use `StateSchema::apply` (not `merge`) with an explicit `Update` type:

```rust
use serde::{Deserialize, Serialize};
use wesichain_graph::StateSchema;

#[derive(Clone, Default, Debug, Serialize, Deserialize)]
struct AppState {
    input: String,
    answer: Option<String>,
}

impl StateSchema for AppState {
    type Update = AppState;

    fn apply(current: &Self, update: Self::Update) -> Self {
        Self {
            input: if update.input.is_empty() {
                current.input.clone()
            } else {
                update.input
            },
            answer: update.answer.or_else(|| current.answer.clone()),
        }
    }
}
```

## Practical Advice

- Start by running existing examples before building custom abstractions.
- Keep your initial migration modular: `core + llm + graph`, then add retrieval/checkpoint crates.
- Use `wesichain-compat` for incremental migration-oriented workflows.
- Treat `wesichain-agent` as the evolving v0.3 runtime track, not the default starting point for stable graph-based projects.

## Next Steps

- [Installation](/docs/getting-started/installation)
- [Quick Start - ReAct Agent](/docs/getting-started/quickstart-react)
- [Architecture Overview](/docs/architecture/overview)
